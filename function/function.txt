C++中函数最需注意的，常用的就是其返回类型，返回形式，参数传递方式
函数调用的栈侦，每次在调用函数时会在系统的栈上存储函数里的参数，函数结束后，栈里的数据会被释放
有值传递，地址传递，引用传递
1.值传递：就是直接传递给函数形参，其特点是传递的时候会从实参拷贝一份副本传递给实参，因此，函数内部对形参的改变都不会改变实参里的值
2.引用传递：就是实参作为引用传递给实参，类似于引用的初始化，其作用就是能改变实参里的值
3.指针传递：类似于指针的初始化传参，将实参的地址传给指针类型的形参，作用也是能修改实参里的值，但是其本质还是值传递，因为形参获取到的是地址，指针本身也是一个对象，所以两个是不同的指针（相当于副本），但都能
指向同一块内存，操作里面的值，但是改不了原指针的指向。
为了提高程序运行效率，我们通常采用后面两种形式的参数传递，可以避免不必要的内存消耗，因为值传递会创建一个与实参一样的数据类型和数据值（副本），如果实参是不可修改的，我们可以在
形参处加个const限定符
4.默认参数：函数在声明的时候，可以给指定参数赋予一个值，在函数调用的时候如果没有给指定参数传值，会使用声明时候的默认参数，也就是说调用函数的时候可以不用给默认参数传参
也可以传。
5.返回值：函数里的参数在函数调用结束后，会被销毁，返回形式是通过拷贝或者移动数据给函数调用者
值返回的本质：数据复制
当返回局部变量，编译器会：1.创建副本：将局部变量的值复制到一个临时对象中 2.销毁局部变量：函数结束，局部变量被释放
3.传递临时对象：其生命周期延长至调用表达式结束
禁止返回局部变量的引用或者指针，因为局部变量已经被销毁，会导致未定义和悬空指针
什么是悬空指针：很好的例子就是超市里的储物柜，每个储物柜上有编号（理解为内存的地址），在函数调用结束后（离开超市，工作人员清理柜子，柜子里的东西被清理，理解为局部变量被释放，但是柜子的编号还在）
你手上有一个取件码（指针），你自己柜子里的东西被清理了，你在拿取件码去开取你的柜子，里面有可能不是你自己的东西（这就是悬空指针）
空指针：就是你那个柜子里不能存东西，里面没有东西
正常指针（有效）	拿着有效的取件码，柜子里是自己的东西	有效地址（A01）	正确拿到自己的东西
悬空指针	拿着旧取件码，柜子里是别人的东西 / 乱码	有效地址（A01）	看到随机内容 / 破坏别人的东西（未定义行为）
空指针	取件码上写着 “无”	无效地址（nullptr）	明确报错（不会乱搞）
6.lambda函数，也叫匿名函数，其功能与普通函数一样，语法：[capture list](parameter list) -> return type { function body }
1. [capture list]：捕获当前作用域的变量
值捕获：[x] 复制变量 x 的值到 Lambda 内部
引用捕获：[&x] 让 Lambda 持有 x 的引用（不复制）
隐式捕获：[=] 值捕获所有变量，[&] 引用捕获所有变量
2. (parameter list)：调用 Lambda 时传入的参数
和普通函数的参数列表完全一样，调用时必须按顺序传入对应类型的参数。
3. -> return type：返回类型（可省略）
多数情况下编译器能自动推导，只有返回类型不唯一时需要显式指定。
4. { function body }：函数体
和普通函数的函数体一样，可以使用捕获的变量和传入的参数。
调用方式：存储调用，将lambda表达式赋值给一个变量（通常用auto自动推导类型），在调用的时候与普通函数调用类似，lambda参数里有几个参数，就传入几个参数
如若参数列表为空，调用lambda函数时也不用传入参数
5.函数和数组：在对数组进行操作的时候，数组作为函数的参数，数组大小作为第二个参数，在调用函数的时候将数组名传入即可，原始的形参为指针类型，因为数组名会被解释成地址，也就是类似于地址
传参，此时可以把形参看成指向数组的第一个元素的指针，也可以看成数组名，因为传递的时候是地址传递，会改变原数组的元素，如果我们不想改变原数组的内容可以在形参处加const限定类型
内存释放不是 “销毁地址”，而是 “标记为可用”；局部变量的引用指向的是 “已被标记为可用的空闲地址”，虽然地址还在，但数据随时可能被其他变量覆盖，访问它就像 “去已经退房的酒店房间找自己的东西”—— 房间还在，但里面的东西可能早就被新住客换了，结果完全不可控
lambda 补充：
1.对于值捕获，[=]获取的是这个作用域里的所有变量，但是有个问题，就是默认的lambda函数是有个const修饰的,即对捕获的副本进行写操作会报错，我们只需要在参数列表()后添加mutable关键字即可
对于引用形式的捕获不会有这种限制，还有捕获列表形式还有[this]捕获外部的类对象，lambda里可以通过这个对象访问它的属性或者类方法
2.对于返回方式
当函数体里只有一种返回时，通常lambda里的形式 []()->ret {}里的ret可以省略，但多于一个return 我们就不能省略->ret，ret要写成返回的数据类型。
3.自动调用：
花括号里的参要和参数列表里的一致（数据类型）














