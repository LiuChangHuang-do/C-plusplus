给定一个非递减顺序排列的数组，要求返回其平方和，且新的数组的排列方式也是非递减顺序
一：我们拿到这道题最先想到的方法就是遍历数组里的每个元素，将每个元素的平方赋值给对应的位置，然后我们再用冒泡排序即可。
void function(int *arr,int size){
	for(int i = 0; i < size; i++){
		arr[i] = arr[i] * arr[i];
	}
	sort(arr,arr + size);
	//手撕冒泡
	for(int a = 0; a < size -1 ; i++){
	    for(int b = 0;b < size - 1 - a; b++){
	    	if(arr[b] > arr[b + 1]){
	    	   swap(arr[b],arr[b + 1]);
	    		}
		}
	}
}
法二：根据题目的特性，非递减的特性此时有负数的话，负数的平方也有可能比正数那边的大，因此，最大的数只有在两边取得，那我们就有思路了，头和尾设置指针
依次遍历比较这两个数的平方的大小，大的那个加入到一个新的数组里（加到末尾，定一个和原数组一样大的数组，存储这些平方值）,画图然后自己动手操作就容易理解点
void function(int *arr,int size){
	int arr_2[size];
	for(int i = 0,int j = size -1; i <= j;){
		if(arr[i] * arr[i] > arr[j] * arr[j]){
			arr[size] = arr[i] * arr[i];
			size--;
			i++;
		
		}
		else{
		      arr[size] = arr[j] * arr[j];
		      size--;
		      j--;
		}
	}
}
