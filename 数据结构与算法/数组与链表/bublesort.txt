冒泡排序，最常用也是最先入门的排序方法，知道冒泡排序原理也挺好的，当然直接使用alrithom文件提供的内置sort函数也可以，但自己理解，手搓是最好的，跟着黑马的思路就挺好的，有图解。这个sort就是将最最大的数排在末尾处，泡泡上升的过程中，末尾是最大的。思路就是将每个数进行比较，但是我们发现一个难题就只是比较了一轮，因为我们做的只是一个数依次与其它数比较，那第一轮下来我们就只获得最大的数，其它数的顺序还是不变，因此我们要找到比较次数与比较轮数的关系，每一个序列比较次数是原素个数 -1，每一次比较轮数是上一次减一，这个自己画图操作就知道了。上代码！！,这思路很明显就用到嵌套for循环，因为我们要考虑记录轮数，还有每次轮数都要比较前后数字大小
viod bublesort(int *arry , int size){
  for(int i = 0; i < size -1 ; i++){
   for(int j = 0; j < size -1 - i; j++){
   if(arry[j] > arry[j + 1]){
     std::swap(arry[j],arry[j + 1]); 
   }
   
  }
  }

}
