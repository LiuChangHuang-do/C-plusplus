在C++中，运算符有其优先级，先乘除后加减，/号运算符中如果两个数都是整数则计算结果也是整数，小数部分被丢弃
%取模运算符的使用规则必须是两个操作数必须是整数，浮点数会报错，（）的优先级大于一切运算符
逻辑运算符的优先级低于关系运算符
cin 的恶梦：
cin是iostream类中的一个实例对象，也是一种输入流，当我们从键盘中输入数据给变量的时候，会做出三件事
1.将数据存入到缓冲区，当用户按下回车键的时候，缓冲区里的数据会提取到变量中；
2.读取操作时，先检查缓冲区里有没有数据，如果没有则不读取，如果有则读取，cin会根据要读取的数据类型（从第一个有效字符）进行读取，
跳过空白符：默认情况下，cin 会先跳过缓冲区开头的空白符（空格 、回车 \n、制表符 \t 等），直到遇到非空白符，>> 运算符会 自动忽略输入前的空白字符（空格 、回车 \n、制表符 \t 等），直到遇到第一个非空白字符才开始读取。
跳过「前导空白符」：不管读取什么类型（int、double、string），>> 都会先跳过输入中所有的「前导空白符」（空格、回车、制表符等）
读取「连续的目标字符」：跳过前导空白后，开始读取「符合目标类型的连续字符」，直到遇到「非目标类型的字符」或「空白符」时停止
匹配数据类型：从非空白符开始，提取连续的、符合目标类型的字符。
移除已提取的数据：提取完成后，缓冲区里的这些数据会被 “拿走”，剩下的字符留在缓冲区里，供后续读取
3. 处理提取结果（设置状态）
提取结束后，cin 会根据结果设置自身的 “状态标志”：
如果提取成功（比如输入的数字符合 int 类型），状态为 “正常（goodbit）”。
如果提取失败（比如输入字母给 int 变量），状态为 “失败（failbit）”。
如果读到文件结束（比如键盘输入 Ctrl+Z），状态为 “文件结束（eofbit）”。
这些状态会影响 cin 的后续操作：如果处于 “失败” 或 “文件结束” 状态，cin 会停止工作，直到用 cin.clear() 重置状态
4.很多时候 cin 出问题，都是因为 缓冲区残留数据 或 状态标志异常。
 缓冲区残留导致的问题：1. 缓冲区残留导致的问题
比如用 cin >> int 后接 getline(cin, str)：
int num;
cin >> num;  // 输入 "123\n"，提取123后，缓冲区剩 "\n"
string str;
getline(cin, str);  // getline会读取缓冲区剩余的 "\n"，直接返回空行
原因：getline 不会跳过空白符，会直接读取缓冲区里的 \n，导致读取空行。
解决：用 cin.ignore() 清空残留的 \n：
cin >> num;
cin.ignore();  // 忽略缓冲区里的 "\n"
getline(cin, str);  // 正常读取
 状态标志异常导致的问题
当输入不符合类型时（比如给 int 输入 "abc"）：
cin 会设置 failbit（失败标志），之后所有 cin 操作都会 “罢工”（直接跳过）。
缓冲区里的 "abc" 会保留，导致后续读取一直失败。
解决步骤：
用 cin.clear() 重置状态标志（清除 failbit）。
用 cin.ignore() 清空缓冲区里的无效数据：
int num;
cin >> num;  // 输入 "abc"，提取失败，failbit被设置
if (cin.fail()) {
    cin.clear();  // 重置状态
    // 清空缓冲区到回车（最多忽略streamsize::max()个字符）
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}
cin常用方法汇总：getline(cin, str)	读取整行（包括空格，以换行符终止，丢弃换行符）
get()	读取单个字符（包括空白符）
peek()	查看下一个字符，但不移除
putback(c)	将字符 c 放回输入流
ignore(n, delim)	忽略输入流中的 n 个字符，或直到遇到分隔符 delim
clear()	清除错误标志（如 failbit、eofbit）
fail()	判断输入是否失败（如格式错误）
eof()	判断是否到达文件结束（如键盘输入 Ctrl+Z）
----------------------------------------------------
C++中大小写之母转换方式，通常包含<cctype>文件里的函数实现，在这里我们需要用到tolower()和toupper()函数，这两个函数的参数是int类型，也可以直接传入char类型，因为可以隐式转换，返回值也是int类型，如果本来就是大写或者小写，传入后还是不变，例如，将小写字母传入tolower()返回的还是小写字母。
还有一个判断字符是否是字母的函数，比如isalpha(),返回0或1；
但是此方法只限于英文字符转换，传入其他会返回原字符。
计算机中大小写字母的ACSS码相差32，'A'~'Z'的范围是65-90；则'a'~'z'的范围是97-121；
大小写转换：char c = 'A';
char lower_c = c + 32;  // 结果为 'a'


